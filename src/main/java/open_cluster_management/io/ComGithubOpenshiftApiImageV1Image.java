/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package open_cluster_management.io;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import open_cluster_management.io.ComGithubOpenshiftApiImageV1ImageLayer;
import open_cluster_management.io.ComGithubOpenshiftApiImageV1ImageSignature;
import open_cluster_management.io.IoK8sApimachineryPkgApisMetaV1ObjectMetaV2;
import open_cluster_management.io.IoK8sApimachineryPkgRuntimeRawExtension;

/**
 * Image is an immutable representation of a container image and metadata at a point in time. Images are named by taking a hash of their contents (metadata and content) and any change in format, content, or metadata results in a new name. The images resource is primarily for use by cluster administrators and integrations like the cluster image registry - end users instead access images via the imagestreamtags or imagestreamimages resources. While image metadata is stored in the API, any integration that implements the container image registry API must provide its own storage for the raw manifest data, image config, and layer contents.
 */
@ApiModel(description = "Image is an immutable representation of a container image and metadata at a point in time. Images are named by taking a hash of their contents (metadata and content) and any change in format, content, or metadata results in a new name. The images resource is primarily for use by cluster administrators and integrations like the cluster image registry - end users instead access images via the imagestreamtags or imagestreamimages resources. While image metadata is stored in the API, any integration that implements the container image registry API must provide its own storage for the raw manifest data, image config, and layer contents.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-18T17:27:50.678+03:00")
public class ComGithubOpenshiftApiImageV1Image {
  @SerializedName("apiVersion")
  private String apiVersion = null;

  @SerializedName("dockerImageConfig")
  private String dockerImageConfig = null;

  @SerializedName("dockerImageLayers")
  private List<ComGithubOpenshiftApiImageV1ImageLayer> dockerImageLayers = new ArrayList<>();

  @SerializedName("dockerImageManifest")
  private String dockerImageManifest = null;

  @SerializedName("dockerImageManifestMediaType")
  private String dockerImageManifestMediaType = null;

  @SerializedName("dockerImageMetadata")
  private IoK8sApimachineryPkgRuntimeRawExtension dockerImageMetadata = null;

  @SerializedName("dockerImageMetadataVersion")
  private String dockerImageMetadataVersion = null;

  @SerializedName("dockerImageReference")
  private String dockerImageReference = null;

  @SerializedName("dockerImageSignatures")
  private List<byte[]> dockerImageSignatures = null;

  @SerializedName("kind")
  private String kind = null;

  @SerializedName("metadata")
  private IoK8sApimachineryPkgApisMetaV1ObjectMetaV2 metadata = null;

  @SerializedName("signatures")
  private List<ComGithubOpenshiftApiImageV1ImageSignature> signatures = null;

  public ComGithubOpenshiftApiImageV1Image apiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
    return this;
  }

   /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   * @return apiVersion
  **/
  @ApiModelProperty(value = "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources")
  public String getApiVersion() {
    return apiVersion;
  }

  public void setApiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageConfig(String dockerImageConfig) {
    this.dockerImageConfig = dockerImageConfig;
    return this;
  }

   /**
   * DockerImageConfig is a JSON blob that the runtime uses to set up the container. This is a part of manifest schema v2.
   * @return dockerImageConfig
  **/
  @ApiModelProperty(value = "DockerImageConfig is a JSON blob that the runtime uses to set up the container. This is a part of manifest schema v2.")
  public String getDockerImageConfig() {
    return dockerImageConfig;
  }

  public void setDockerImageConfig(String dockerImageConfig) {
    this.dockerImageConfig = dockerImageConfig;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageLayers(List<ComGithubOpenshiftApiImageV1ImageLayer> dockerImageLayers) {
    this.dockerImageLayers = dockerImageLayers;
    return this;
  }

  public ComGithubOpenshiftApiImageV1Image addDockerImageLayersItem(ComGithubOpenshiftApiImageV1ImageLayer dockerImageLayersItem) {
    this.dockerImageLayers.add(dockerImageLayersItem);
    return this;
  }

   /**
   * DockerImageLayers represents the layers in the image. May not be set if the image does not define that data.
   * @return dockerImageLayers
  **/
  @ApiModelProperty(required = true, value = "DockerImageLayers represents the layers in the image. May not be set if the image does not define that data.")
  public List<ComGithubOpenshiftApiImageV1ImageLayer> getDockerImageLayers() {
    return dockerImageLayers;
  }

  public void setDockerImageLayers(List<ComGithubOpenshiftApiImageV1ImageLayer> dockerImageLayers) {
    this.dockerImageLayers = dockerImageLayers;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageManifest(String dockerImageManifest) {
    this.dockerImageManifest = dockerImageManifest;
    return this;
  }

   /**
   * DockerImageManifest is the raw JSON of the manifest
   * @return dockerImageManifest
  **/
  @ApiModelProperty(value = "DockerImageManifest is the raw JSON of the manifest")
  public String getDockerImageManifest() {
    return dockerImageManifest;
  }

  public void setDockerImageManifest(String dockerImageManifest) {
    this.dockerImageManifest = dockerImageManifest;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageManifestMediaType(String dockerImageManifestMediaType) {
    this.dockerImageManifestMediaType = dockerImageManifestMediaType;
    return this;
  }

   /**
   * DockerImageManifestMediaType specifies the mediaType of manifest. This is a part of manifest schema v2.
   * @return dockerImageManifestMediaType
  **/
  @ApiModelProperty(value = "DockerImageManifestMediaType specifies the mediaType of manifest. This is a part of manifest schema v2.")
  public String getDockerImageManifestMediaType() {
    return dockerImageManifestMediaType;
  }

  public void setDockerImageManifestMediaType(String dockerImageManifestMediaType) {
    this.dockerImageManifestMediaType = dockerImageManifestMediaType;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageMetadata(IoK8sApimachineryPkgRuntimeRawExtension dockerImageMetadata) {
    this.dockerImageMetadata = dockerImageMetadata;
    return this;
  }

   /**
   * DockerImageMetadata contains metadata about this image
   * @return dockerImageMetadata
  **/
  @ApiModelProperty(value = "DockerImageMetadata contains metadata about this image")
  public IoK8sApimachineryPkgRuntimeRawExtension getDockerImageMetadata() {
    return dockerImageMetadata;
  }

  public void setDockerImageMetadata(IoK8sApimachineryPkgRuntimeRawExtension dockerImageMetadata) {
    this.dockerImageMetadata = dockerImageMetadata;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageMetadataVersion(String dockerImageMetadataVersion) {
    this.dockerImageMetadataVersion = dockerImageMetadataVersion;
    return this;
  }

   /**
   * DockerImageMetadataVersion conveys the version of the object, which if empty defaults to \&quot;1.0\&quot;
   * @return dockerImageMetadataVersion
  **/
  @ApiModelProperty(value = "DockerImageMetadataVersion conveys the version of the object, which if empty defaults to \"1.0\"")
  public String getDockerImageMetadataVersion() {
    return dockerImageMetadataVersion;
  }

  public void setDockerImageMetadataVersion(String dockerImageMetadataVersion) {
    this.dockerImageMetadataVersion = dockerImageMetadataVersion;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageReference(String dockerImageReference) {
    this.dockerImageReference = dockerImageReference;
    return this;
  }

   /**
   * DockerImageReference is the string that can be used to pull this image.
   * @return dockerImageReference
  **/
  @ApiModelProperty(value = "DockerImageReference is the string that can be used to pull this image.")
  public String getDockerImageReference() {
    return dockerImageReference;
  }

  public void setDockerImageReference(String dockerImageReference) {
    this.dockerImageReference = dockerImageReference;
  }

  public ComGithubOpenshiftApiImageV1Image dockerImageSignatures(List<byte[]> dockerImageSignatures) {
    this.dockerImageSignatures = dockerImageSignatures;
    return this;
  }

  public ComGithubOpenshiftApiImageV1Image addDockerImageSignaturesItem(byte[] dockerImageSignaturesItem) {
    if (this.dockerImageSignatures == null) {
      this.dockerImageSignatures = new ArrayList<>();
    }
    this.dockerImageSignatures.add(dockerImageSignaturesItem);
    return this;
  }

   /**
   * DockerImageSignatures provides the signatures as opaque blobs. This is a part of manifest schema v1.
   * @return dockerImageSignatures
  **/
  @ApiModelProperty(value = "DockerImageSignatures provides the signatures as opaque blobs. This is a part of manifest schema v1.")
  public List<byte[]> getDockerImageSignatures() {
    return dockerImageSignatures;
  }

  public void setDockerImageSignatures(List<byte[]> dockerImageSignatures) {
    this.dockerImageSignatures = dockerImageSignatures;
  }

  public ComGithubOpenshiftApiImageV1Image kind(String kind) {
    this.kind = kind;
    return this;
  }

   /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * @return kind
  **/
  @ApiModelProperty(value = "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds")
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }

  public ComGithubOpenshiftApiImageV1Image metadata(IoK8sApimachineryPkgApisMetaV1ObjectMetaV2 metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @ApiModelProperty(value = "")
  public IoK8sApimachineryPkgApisMetaV1ObjectMetaV2 getMetadata() {
    return metadata;
  }

  public void setMetadata(IoK8sApimachineryPkgApisMetaV1ObjectMetaV2 metadata) {
    this.metadata = metadata;
  }

  public ComGithubOpenshiftApiImageV1Image signatures(List<ComGithubOpenshiftApiImageV1ImageSignature> signatures) {
    this.signatures = signatures;
    return this;
  }

  public ComGithubOpenshiftApiImageV1Image addSignaturesItem(ComGithubOpenshiftApiImageV1ImageSignature signaturesItem) {
    if (this.signatures == null) {
      this.signatures = new ArrayList<>();
    }
    this.signatures.add(signaturesItem);
    return this;
  }

   /**
   * Signatures holds all signatures of the image.
   * @return signatures
  **/
  @ApiModelProperty(value = "Signatures holds all signatures of the image.")
  public List<ComGithubOpenshiftApiImageV1ImageSignature> getSignatures() {
    return signatures;
  }

  public void setSignatures(List<ComGithubOpenshiftApiImageV1ImageSignature> signatures) {
    this.signatures = signatures;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComGithubOpenshiftApiImageV1Image comGithubOpenshiftApiImageV1Image = (ComGithubOpenshiftApiImageV1Image) o;
    return Objects.equals(this.apiVersion, comGithubOpenshiftApiImageV1Image.apiVersion) &&
        Objects.equals(this.dockerImageConfig, comGithubOpenshiftApiImageV1Image.dockerImageConfig) &&
        Objects.equals(this.dockerImageLayers, comGithubOpenshiftApiImageV1Image.dockerImageLayers) &&
        Objects.equals(this.dockerImageManifest, comGithubOpenshiftApiImageV1Image.dockerImageManifest) &&
        Objects.equals(this.dockerImageManifestMediaType, comGithubOpenshiftApiImageV1Image.dockerImageManifestMediaType) &&
        Objects.equals(this.dockerImageMetadata, comGithubOpenshiftApiImageV1Image.dockerImageMetadata) &&
        Objects.equals(this.dockerImageMetadataVersion, comGithubOpenshiftApiImageV1Image.dockerImageMetadataVersion) &&
        Objects.equals(this.dockerImageReference, comGithubOpenshiftApiImageV1Image.dockerImageReference) &&
        Objects.equals(this.dockerImageSignatures, comGithubOpenshiftApiImageV1Image.dockerImageSignatures) &&
        Objects.equals(this.kind, comGithubOpenshiftApiImageV1Image.kind) &&
        Objects.equals(this.metadata, comGithubOpenshiftApiImageV1Image.metadata) &&
        Objects.equals(this.signatures, comGithubOpenshiftApiImageV1Image.signatures);
  }

  @Override
  public int hashCode() {
    return Objects.hash(apiVersion, dockerImageConfig, dockerImageLayers, dockerImageManifest, dockerImageManifestMediaType, dockerImageMetadata, dockerImageMetadataVersion, dockerImageReference, dockerImageSignatures, kind, metadata, signatures);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComGithubOpenshiftApiImageV1Image {\n");
    
    sb.append("    apiVersion: ").append(toIndentedString(apiVersion)).append("\n");
    sb.append("    dockerImageConfig: ").append(toIndentedString(dockerImageConfig)).append("\n");
    sb.append("    dockerImageLayers: ").append(toIndentedString(dockerImageLayers)).append("\n");
    sb.append("    dockerImageManifest: ").append(toIndentedString(dockerImageManifest)).append("\n");
    sb.append("    dockerImageManifestMediaType: ").append(toIndentedString(dockerImageManifestMediaType)).append("\n");
    sb.append("    dockerImageMetadata: ").append(toIndentedString(dockerImageMetadata)).append("\n");
    sb.append("    dockerImageMetadataVersion: ").append(toIndentedString(dockerImageMetadataVersion)).append("\n");
    sb.append("    dockerImageReference: ").append(toIndentedString(dockerImageReference)).append("\n");
    sb.append("    dockerImageSignatures: ").append(toIndentedString(dockerImageSignatures)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    signatures: ").append(toIndentedString(signatures)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

