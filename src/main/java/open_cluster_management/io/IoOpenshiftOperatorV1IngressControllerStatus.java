/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package open_cluster_management.io;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import open_cluster_management.io.IoOpenshiftOperatorImageregistryV1ConfigStatusConditions;
import open_cluster_management.io.IoOpenshiftOperatorV1IngressControllerStatusEndpointPublishingStrategy;
import open_cluster_management.io.IoOpenshiftOperatorV1IngressControllerStatusTlsProfile;

/**
 * status is the most recently observed status of the IngressController.
 */
@ApiModel(description = "status is the most recently observed status of the IngressController.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-18T17:27:50.678+03:00")
public class IoOpenshiftOperatorV1IngressControllerStatus {
  @SerializedName("availableReplicas")
  private Integer availableReplicas = null;

  @SerializedName("conditions")
  private List<IoOpenshiftOperatorImageregistryV1ConfigStatusConditions> conditions = null;

  @SerializedName("domain")
  private String domain = null;

  @SerializedName("endpointPublishingStrategy")
  private IoOpenshiftOperatorV1IngressControllerStatusEndpointPublishingStrategy endpointPublishingStrategy = null;

  @SerializedName("observedGeneration")
  private Long observedGeneration = null;

  @SerializedName("selector")
  private String selector = null;

  @SerializedName("tlsProfile")
  private IoOpenshiftOperatorV1IngressControllerStatusTlsProfile tlsProfile = null;

  public IoOpenshiftOperatorV1IngressControllerStatus availableReplicas(Integer availableReplicas) {
    this.availableReplicas = availableReplicas;
    return this;
  }

   /**
   * availableReplicas is number of observed available replicas according to the ingress controller deployment.
   * @return availableReplicas
  **/
  @ApiModelProperty(value = "availableReplicas is number of observed available replicas according to the ingress controller deployment.")
  public Integer getAvailableReplicas() {
    return availableReplicas;
  }

  public void setAvailableReplicas(Integer availableReplicas) {
    this.availableReplicas = availableReplicas;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus conditions(List<IoOpenshiftOperatorImageregistryV1ConfigStatusConditions> conditions) {
    this.conditions = conditions;
    return this;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus addConditionsItem(IoOpenshiftOperatorImageregistryV1ConfigStatusConditions conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * conditions is a list of conditions and their status.   Available means the ingress controller deployment is available and servicing route and ingress resources (i.e, .status.availableReplicas equals .spec.replicas)   There are additional conditions which indicate the status of other ingress controller features and capabilities.     * LoadBalancerManaged   - True if the following conditions are met:     * The endpoint publishing strategy requires a service load balancer.   - False if any of those conditions are unsatisfied.     * LoadBalancerReady   - True if the following conditions are met:     * A load balancer is managed.     * The load balancer is ready.   - False if any of those conditions are unsatisfied.     * DNSManaged   - True if the following conditions are met:     * The endpoint publishing strategy and platform support DNS.     * The ingress controller domain is set.     * dns.config.openshift.io/cluster configures DNS zones.   - False if any of those conditions are unsatisfied.     * DNSReady   - True if the following conditions are met:     * DNS is managed.     * DNS records have been successfully created.   - False if any of those conditions are unsatisfied.
   * @return conditions
  **/
  @ApiModelProperty(value = "conditions is a list of conditions and their status.   Available means the ingress controller deployment is available and servicing route and ingress resources (i.e, .status.availableReplicas equals .spec.replicas)   There are additional conditions which indicate the status of other ingress controller features and capabilities.     * LoadBalancerManaged   - True if the following conditions are met:     * The endpoint publishing strategy requires a service load balancer.   - False if any of those conditions are unsatisfied.     * LoadBalancerReady   - True if the following conditions are met:     * A load balancer is managed.     * The load balancer is ready.   - False if any of those conditions are unsatisfied.     * DNSManaged   - True if the following conditions are met:     * The endpoint publishing strategy and platform support DNS.     * The ingress controller domain is set.     * dns.config.openshift.io/cluster configures DNS zones.   - False if any of those conditions are unsatisfied.     * DNSReady   - True if the following conditions are met:     * DNS is managed.     * DNS records have been successfully created.   - False if any of those conditions are unsatisfied.")
  public List<IoOpenshiftOperatorImageregistryV1ConfigStatusConditions> getConditions() {
    return conditions;
  }

  public void setConditions(List<IoOpenshiftOperatorImageregistryV1ConfigStatusConditions> conditions) {
    this.conditions = conditions;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus domain(String domain) {
    this.domain = domain;
    return this;
  }

   /**
   * domain is the actual domain in use.
   * @return domain
  **/
  @ApiModelProperty(value = "domain is the actual domain in use.")
  public String getDomain() {
    return domain;
  }

  public void setDomain(String domain) {
    this.domain = domain;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus endpointPublishingStrategy(IoOpenshiftOperatorV1IngressControllerStatusEndpointPublishingStrategy endpointPublishingStrategy) {
    this.endpointPublishingStrategy = endpointPublishingStrategy;
    return this;
  }

   /**
   * Get endpointPublishingStrategy
   * @return endpointPublishingStrategy
  **/
  @ApiModelProperty(value = "")
  public IoOpenshiftOperatorV1IngressControllerStatusEndpointPublishingStrategy getEndpointPublishingStrategy() {
    return endpointPublishingStrategy;
  }

  public void setEndpointPublishingStrategy(IoOpenshiftOperatorV1IngressControllerStatusEndpointPublishingStrategy endpointPublishingStrategy) {
    this.endpointPublishingStrategy = endpointPublishingStrategy;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus observedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
    return this;
  }

   /**
   * observedGeneration is the most recent generation observed.
   * @return observedGeneration
  **/
  @ApiModelProperty(value = "observedGeneration is the most recent generation observed.")
  public Long getObservedGeneration() {
    return observedGeneration;
  }

  public void setObservedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus selector(String selector) {
    this.selector = selector;
    return this;
  }

   /**
   * selector is a label selector, in string format, for ingress controller pods corresponding to the IngressController. The number of matching pods should equal the value of availableReplicas.
   * @return selector
  **/
  @ApiModelProperty(value = "selector is a label selector, in string format, for ingress controller pods corresponding to the IngressController. The number of matching pods should equal the value of availableReplicas.")
  public String getSelector() {
    return selector;
  }

  public void setSelector(String selector) {
    this.selector = selector;
  }

  public IoOpenshiftOperatorV1IngressControllerStatus tlsProfile(IoOpenshiftOperatorV1IngressControllerStatusTlsProfile tlsProfile) {
    this.tlsProfile = tlsProfile;
    return this;
  }

   /**
   * Get tlsProfile
   * @return tlsProfile
  **/
  @ApiModelProperty(value = "")
  public IoOpenshiftOperatorV1IngressControllerStatusTlsProfile getTlsProfile() {
    return tlsProfile;
  }

  public void setTlsProfile(IoOpenshiftOperatorV1IngressControllerStatusTlsProfile tlsProfile) {
    this.tlsProfile = tlsProfile;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoOpenshiftOperatorV1IngressControllerStatus ioOpenshiftOperatorV1IngressControllerStatus = (IoOpenshiftOperatorV1IngressControllerStatus) o;
    return Objects.equals(this.availableReplicas, ioOpenshiftOperatorV1IngressControllerStatus.availableReplicas) &&
        Objects.equals(this.conditions, ioOpenshiftOperatorV1IngressControllerStatus.conditions) &&
        Objects.equals(this.domain, ioOpenshiftOperatorV1IngressControllerStatus.domain) &&
        Objects.equals(this.endpointPublishingStrategy, ioOpenshiftOperatorV1IngressControllerStatus.endpointPublishingStrategy) &&
        Objects.equals(this.observedGeneration, ioOpenshiftOperatorV1IngressControllerStatus.observedGeneration) &&
        Objects.equals(this.selector, ioOpenshiftOperatorV1IngressControllerStatus.selector) &&
        Objects.equals(this.tlsProfile, ioOpenshiftOperatorV1IngressControllerStatus.tlsProfile);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableReplicas, conditions, domain, endpointPublishingStrategy, observedGeneration, selector, tlsProfile);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoOpenshiftOperatorV1IngressControllerStatus {\n");
    
    sb.append("    availableReplicas: ").append(toIndentedString(availableReplicas)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    endpointPublishingStrategy: ").append(toIndentedString(endpointPublishingStrategy)).append("\n");
    sb.append("    observedGeneration: ").append(toIndentedString(observedGeneration)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    tlsProfile: ").append(toIndentedString(tlsProfile)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

