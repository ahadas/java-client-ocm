/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package open_cluster_management.io;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import open_cluster_management.io.ComGithubOpenshiftApiImageV1NamedTagEventList;

/**
 * ImageStreamStatus contains information about the state of this image stream.
 */
@ApiModel(description = "ImageStreamStatus contains information about the state of this image stream.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-18T17:27:50.678+03:00")
public class ComGithubOpenshiftApiImageV1ImageStreamStatus {
  @SerializedName("dockerImageRepository")
  private String dockerImageRepository = null;

  @SerializedName("publicDockerImageRepository")
  private String publicDockerImageRepository = null;

  @SerializedName("tags")
  private List<ComGithubOpenshiftApiImageV1NamedTagEventList> tags = null;

  public ComGithubOpenshiftApiImageV1ImageStreamStatus dockerImageRepository(String dockerImageRepository) {
    this.dockerImageRepository = dockerImageRepository;
    return this;
  }

   /**
   * DockerImageRepository represents the effective location this stream may be accessed at. May be empty until the server determines where the repository is located
   * @return dockerImageRepository
  **/
  @ApiModelProperty(required = true, value = "DockerImageRepository represents the effective location this stream may be accessed at. May be empty until the server determines where the repository is located")
  public String getDockerImageRepository() {
    return dockerImageRepository;
  }

  public void setDockerImageRepository(String dockerImageRepository) {
    this.dockerImageRepository = dockerImageRepository;
  }

  public ComGithubOpenshiftApiImageV1ImageStreamStatus publicDockerImageRepository(String publicDockerImageRepository) {
    this.publicDockerImageRepository = publicDockerImageRepository;
    return this;
  }

   /**
   * PublicDockerImageRepository represents the public location from where the image can be pulled outside the cluster. This field may be empty if the administrator has not exposed the integrated registry externally.
   * @return publicDockerImageRepository
  **/
  @ApiModelProperty(value = "PublicDockerImageRepository represents the public location from where the image can be pulled outside the cluster. This field may be empty if the administrator has not exposed the integrated registry externally.")
  public String getPublicDockerImageRepository() {
    return publicDockerImageRepository;
  }

  public void setPublicDockerImageRepository(String publicDockerImageRepository) {
    this.publicDockerImageRepository = publicDockerImageRepository;
  }

  public ComGithubOpenshiftApiImageV1ImageStreamStatus tags(List<ComGithubOpenshiftApiImageV1NamedTagEventList> tags) {
    this.tags = tags;
    return this;
  }

  public ComGithubOpenshiftApiImageV1ImageStreamStatus addTagsItem(ComGithubOpenshiftApiImageV1NamedTagEventList tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * Tags are a historical record of images associated with each tag. The first entry in the TagEvent array is the currently tagged image.
   * @return tags
  **/
  @ApiModelProperty(value = "Tags are a historical record of images associated with each tag. The first entry in the TagEvent array is the currently tagged image.")
  public List<ComGithubOpenshiftApiImageV1NamedTagEventList> getTags() {
    return tags;
  }

  public void setTags(List<ComGithubOpenshiftApiImageV1NamedTagEventList> tags) {
    this.tags = tags;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComGithubOpenshiftApiImageV1ImageStreamStatus comGithubOpenshiftApiImageV1ImageStreamStatus = (ComGithubOpenshiftApiImageV1ImageStreamStatus) o;
    return Objects.equals(this.dockerImageRepository, comGithubOpenshiftApiImageV1ImageStreamStatus.dockerImageRepository) &&
        Objects.equals(this.publicDockerImageRepository, comGithubOpenshiftApiImageV1ImageStreamStatus.publicDockerImageRepository) &&
        Objects.equals(this.tags, comGithubOpenshiftApiImageV1ImageStreamStatus.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dockerImageRepository, publicDockerImageRepository, tags);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComGithubOpenshiftApiImageV1ImageStreamStatus {\n");
    
    sb.append("    dockerImageRepository: ").append(toIndentedString(dockerImageRepository)).append("\n");
    sb.append("    publicDockerImageRepository: ").append(toIndentedString(publicDockerImageRepository)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

