/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package open_cluster_management.io;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import open_cluster_management.io.IoOpenshiftConfigV1ClusterOperatorStatusConditions;
import open_cluster_management.io.IoOpenshiftConfigV1ClusterVersionStatusDesired;
import open_cluster_management.io.IoOpenshiftConfigV1ClusterVersionStatusHistory;

/**
 * status contains information about the available updates and any in-progress updates.
 */
@ApiModel(description = "status contains information about the available updates and any in-progress updates.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-18T17:27:50.678+03:00")
public class IoOpenshiftConfigV1ClusterVersionStatus {
  @SerializedName("availableUpdates")
  private Object availableUpdates = null;

  @SerializedName("conditions")
  private List<IoOpenshiftConfigV1ClusterOperatorStatusConditions> conditions = null;

  @SerializedName("desired")
  private IoOpenshiftConfigV1ClusterVersionStatusDesired desired = null;

  @SerializedName("history")
  private List<IoOpenshiftConfigV1ClusterVersionStatusHistory> history = null;

  @SerializedName("observedGeneration")
  private Long observedGeneration = null;

  @SerializedName("versionHash")
  private String versionHash = null;

  public IoOpenshiftConfigV1ClusterVersionStatus availableUpdates(Object availableUpdates) {
    this.availableUpdates = availableUpdates;
    return this;
  }

   /**
   * availableUpdates contains the list of updates that are appropriate for this cluster. This list may be empty if no updates are recommended, if the update service is unavailable, or if an invalid channel has been specified.
   * @return availableUpdates
  **/
  @ApiModelProperty(required = true, value = "availableUpdates contains the list of updates that are appropriate for this cluster. This list may be empty if no updates are recommended, if the update service is unavailable, or if an invalid channel has been specified.")
  public Object getAvailableUpdates() {
    return availableUpdates;
  }

  public void setAvailableUpdates(Object availableUpdates) {
    this.availableUpdates = availableUpdates;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus conditions(List<IoOpenshiftConfigV1ClusterOperatorStatusConditions> conditions) {
    this.conditions = conditions;
    return this;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus addConditionsItem(IoOpenshiftConfigV1ClusterOperatorStatusConditions conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * conditions provides information about the cluster version. The condition \&quot;Available\&quot; is set to true if the desiredUpdate has been reached. The condition \&quot;Progressing\&quot; is set to true if an update is being applied. The condition \&quot;Degraded\&quot; is set to true if an update is currently blocked by a temporary or permanent error. Conditions are only valid for the current desiredUpdate when metadata.generation is equal to status.generation.
   * @return conditions
  **/
  @ApiModelProperty(value = "conditions provides information about the cluster version. The condition \"Available\" is set to true if the desiredUpdate has been reached. The condition \"Progressing\" is set to true if an update is being applied. The condition \"Degraded\" is set to true if an update is currently blocked by a temporary or permanent error. Conditions are only valid for the current desiredUpdate when metadata.generation is equal to status.generation.")
  public List<IoOpenshiftConfigV1ClusterOperatorStatusConditions> getConditions() {
    return conditions;
  }

  public void setConditions(List<IoOpenshiftConfigV1ClusterOperatorStatusConditions> conditions) {
    this.conditions = conditions;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus desired(IoOpenshiftConfigV1ClusterVersionStatusDesired desired) {
    this.desired = desired;
    return this;
  }

   /**
   * Get desired
   * @return desired
  **/
  @ApiModelProperty(required = true, value = "")
  public IoOpenshiftConfigV1ClusterVersionStatusDesired getDesired() {
    return desired;
  }

  public void setDesired(IoOpenshiftConfigV1ClusterVersionStatusDesired desired) {
    this.desired = desired;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus history(List<IoOpenshiftConfigV1ClusterVersionStatusHistory> history) {
    this.history = history;
    return this;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus addHistoryItem(IoOpenshiftConfigV1ClusterVersionStatusHistory historyItem) {
    if (this.history == null) {
      this.history = new ArrayList<>();
    }
    this.history.add(historyItem);
    return this;
  }

   /**
   * history contains a list of the most recent versions applied to the cluster. This value may be empty during cluster startup, and then will be updated when a new update is being applied. The newest update is first in the list and it is ordered by recency. Updates in the history have state Completed if the rollout completed - if an update was failing or halfway applied the state will be Partial. Only a limited amount of update history is preserved.
   * @return history
  **/
  @ApiModelProperty(value = "history contains a list of the most recent versions applied to the cluster. This value may be empty during cluster startup, and then will be updated when a new update is being applied. The newest update is first in the list and it is ordered by recency. Updates in the history have state Completed if the rollout completed - if an update was failing or halfway applied the state will be Partial. Only a limited amount of update history is preserved.")
  public List<IoOpenshiftConfigV1ClusterVersionStatusHistory> getHistory() {
    return history;
  }

  public void setHistory(List<IoOpenshiftConfigV1ClusterVersionStatusHistory> history) {
    this.history = history;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus observedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
    return this;
  }

   /**
   * observedGeneration reports which version of the spec is being synced. If this value is not equal to metadata.generation, then the desired and conditions fields may represent a previous version.
   * @return observedGeneration
  **/
  @ApiModelProperty(required = true, value = "observedGeneration reports which version of the spec is being synced. If this value is not equal to metadata.generation, then the desired and conditions fields may represent a previous version.")
  public Long getObservedGeneration() {
    return observedGeneration;
  }

  public void setObservedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
  }

  public IoOpenshiftConfigV1ClusterVersionStatus versionHash(String versionHash) {
    this.versionHash = versionHash;
    return this;
  }

   /**
   * versionHash is a fingerprint of the content that the cluster will be updated with. It is used by the operator to avoid unnecessary work and is for internal use only.
   * @return versionHash
  **/
  @ApiModelProperty(required = true, value = "versionHash is a fingerprint of the content that the cluster will be updated with. It is used by the operator to avoid unnecessary work and is for internal use only.")
  public String getVersionHash() {
    return versionHash;
  }

  public void setVersionHash(String versionHash) {
    this.versionHash = versionHash;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoOpenshiftConfigV1ClusterVersionStatus ioOpenshiftConfigV1ClusterVersionStatus = (IoOpenshiftConfigV1ClusterVersionStatus) o;
    return Objects.equals(this.availableUpdates, ioOpenshiftConfigV1ClusterVersionStatus.availableUpdates) &&
        Objects.equals(this.conditions, ioOpenshiftConfigV1ClusterVersionStatus.conditions) &&
        Objects.equals(this.desired, ioOpenshiftConfigV1ClusterVersionStatus.desired) &&
        Objects.equals(this.history, ioOpenshiftConfigV1ClusterVersionStatus.history) &&
        Objects.equals(this.observedGeneration, ioOpenshiftConfigV1ClusterVersionStatus.observedGeneration) &&
        Objects.equals(this.versionHash, ioOpenshiftConfigV1ClusterVersionStatus.versionHash);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableUpdates, conditions, desired, history, observedGeneration, versionHash);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoOpenshiftConfigV1ClusterVersionStatus {\n");
    
    sb.append("    availableUpdates: ").append(toIndentedString(availableUpdates)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    desired: ").append(toIndentedString(desired)).append("\n");
    sb.append("    history: ").append(toIndentedString(history)).append("\n");
    sb.append("    observedGeneration: ").append(toIndentedString(observedGeneration)).append("\n");
    sb.append("    versionHash: ").append(toIndentedString(versionHash)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

