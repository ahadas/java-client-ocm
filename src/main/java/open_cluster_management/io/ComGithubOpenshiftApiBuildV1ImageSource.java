/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package open_cluster_management.io;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import open_cluster_management.io.ComGithubOpenshiftApiBuildV1ImageSourcePath;
import open_cluster_management.io.IoK8sApiCoreV1LocalObjectReference;
import open_cluster_management.io.IoK8sApiCoreV1ObjectReference;

/**
 * ImageSource is used to describe build source that will be extracted from an image or used during a multi stage build. A reference of type ImageStreamTag, ImageStreamImage or DockerImage may be used. A pull secret can be specified to pull the image from an external registry or override the default service account secret if pulling from the internal registry. Image sources can either be used to extract content from an image and place it into the build context along with the repository source, or used directly during a multi-stage container image build to allow content to be copied without overwriting the contents of the repository source (see the &#39;paths&#39; and &#39;as&#39; fields).
 */
@ApiModel(description = "ImageSource is used to describe build source that will be extracted from an image or used during a multi stage build. A reference of type ImageStreamTag, ImageStreamImage or DockerImage may be used. A pull secret can be specified to pull the image from an external registry or override the default service account secret if pulling from the internal registry. Image sources can either be used to extract content from an image and place it into the build context along with the repository source, or used directly during a multi-stage container image build to allow content to be copied without overwriting the contents of the repository source (see the 'paths' and 'as' fields).")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-18T17:27:50.678+03:00")
public class ComGithubOpenshiftApiBuildV1ImageSource {
  @SerializedName("as")
  private List<String> as = null;

  @SerializedName("from")
  private IoK8sApiCoreV1ObjectReference from = null;

  @SerializedName("paths")
  private List<ComGithubOpenshiftApiBuildV1ImageSourcePath> paths = null;

  @SerializedName("pullSecret")
  private IoK8sApiCoreV1LocalObjectReference pullSecret = null;

  public ComGithubOpenshiftApiBuildV1ImageSource as(List<String> as) {
    this.as = as;
    return this;
  }

  public ComGithubOpenshiftApiBuildV1ImageSource addAsItem(String asItem) {
    if (this.as == null) {
      this.as = new ArrayList<>();
    }
    this.as.add(asItem);
    return this;
  }

   /**
   * A list of image names that this source will be used in place of during a multi-stage container image build. For instance, a Dockerfile that uses \&quot;COPY --from&#x3D;nginx:latest\&quot; will first check for an image source that has \&quot;nginx:latest\&quot; in this field before attempting to pull directly. If the Dockerfile does not reference an image source it is ignored. This field and paths may both be set, in which case the contents will be used twice.
   * @return as
  **/
  @ApiModelProperty(value = "A list of image names that this source will be used in place of during a multi-stage container image build. For instance, a Dockerfile that uses \"COPY --from=nginx:latest\" will first check for an image source that has \"nginx:latest\" in this field before attempting to pull directly. If the Dockerfile does not reference an image source it is ignored. This field and paths may both be set, in which case the contents will be used twice.")
  public List<String> getAs() {
    return as;
  }

  public void setAs(List<String> as) {
    this.as = as;
  }

  public ComGithubOpenshiftApiBuildV1ImageSource from(IoK8sApiCoreV1ObjectReference from) {
    this.from = from;
    return this;
  }

   /**
   * from is a reference to an ImageStreamTag, ImageStreamImage, or DockerImage to copy source from.
   * @return from
  **/
  @ApiModelProperty(required = true, value = "from is a reference to an ImageStreamTag, ImageStreamImage, or DockerImage to copy source from.")
  public IoK8sApiCoreV1ObjectReference getFrom() {
    return from;
  }

  public void setFrom(IoK8sApiCoreV1ObjectReference from) {
    this.from = from;
  }

  public ComGithubOpenshiftApiBuildV1ImageSource paths(List<ComGithubOpenshiftApiBuildV1ImageSourcePath> paths) {
    this.paths = paths;
    return this;
  }

  public ComGithubOpenshiftApiBuildV1ImageSource addPathsItem(ComGithubOpenshiftApiBuildV1ImageSourcePath pathsItem) {
    if (this.paths == null) {
      this.paths = new ArrayList<>();
    }
    this.paths.add(pathsItem);
    return this;
  }

   /**
   * paths is a list of source and destination paths to copy from the image. This content will be copied into the build context prior to starting the build. If no paths are set, the build context will not be altered.
   * @return paths
  **/
  @ApiModelProperty(value = "paths is a list of source and destination paths to copy from the image. This content will be copied into the build context prior to starting the build. If no paths are set, the build context will not be altered.")
  public List<ComGithubOpenshiftApiBuildV1ImageSourcePath> getPaths() {
    return paths;
  }

  public void setPaths(List<ComGithubOpenshiftApiBuildV1ImageSourcePath> paths) {
    this.paths = paths;
  }

  public ComGithubOpenshiftApiBuildV1ImageSource pullSecret(IoK8sApiCoreV1LocalObjectReference pullSecret) {
    this.pullSecret = pullSecret;
    return this;
  }

   /**
   * pullSecret is a reference to a secret to be used to pull the image from a registry If the image is pulled from the OpenShift registry, this field does not need to be set.
   * @return pullSecret
  **/
  @ApiModelProperty(value = "pullSecret is a reference to a secret to be used to pull the image from a registry If the image is pulled from the OpenShift registry, this field does not need to be set.")
  public IoK8sApiCoreV1LocalObjectReference getPullSecret() {
    return pullSecret;
  }

  public void setPullSecret(IoK8sApiCoreV1LocalObjectReference pullSecret) {
    this.pullSecret = pullSecret;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComGithubOpenshiftApiBuildV1ImageSource comGithubOpenshiftApiBuildV1ImageSource = (ComGithubOpenshiftApiBuildV1ImageSource) o;
    return Objects.equals(this.as, comGithubOpenshiftApiBuildV1ImageSource.as) &&
        Objects.equals(this.from, comGithubOpenshiftApiBuildV1ImageSource.from) &&
        Objects.equals(this.paths, comGithubOpenshiftApiBuildV1ImageSource.paths) &&
        Objects.equals(this.pullSecret, comGithubOpenshiftApiBuildV1ImageSource.pullSecret);
  }

  @Override
  public int hashCode() {
    return Objects.hash(as, from, paths, pullSecret);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComGithubOpenshiftApiBuildV1ImageSource {\n");
    
    sb.append("    as: ").append(toIndentedString(as)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    paths: ").append(toIndentedString(paths)).append("\n");
    sb.append("    pullSecret: ").append(toIndentedString(pullSecret)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

